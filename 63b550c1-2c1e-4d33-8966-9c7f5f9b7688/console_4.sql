select * from words.word;

select jsonb_strip_nulls(
               jsonb_build_object('key_wd', word,
                                  'key_wt', wordtype,
                                  'key_def', definition,
                                  'key_ln', word_length
               ))
from words.word

select jsonb_strip_nulls(
               jsonb_build_object('key_wd', null,
                                  'key_wt', null,
                                  'key_def', null,
                                  'key_ln', null
               ))
from words.word


select regexp_match('and ci = 1 and f = 0 and oc = 2  and rc = 3', '(and [^(and)]+)');

select position((regexp_match('Постанова ВД№5/2 A-2392 від 2-12-2023 hjre', 'ВД№\s*(.+\sвід\s\d{1,2}-\d{1,2}-\d{2,4})*'))[1] in 'text before 5/2 A-2392 від 2-12-2023 text after')


select array['AMJ','AUM','AUX','BACD','BPX','BRB','BSZ','BVZ','CDD','CITD','DBA','DBB','DBC','DBO','DIA','DJX','EEM','EFA','EUI','EUU','GBP','GLD',
			'GSSD','IWM','IWN','IWO','IWV','JJC','JPMD','KBE','KRE','MDY','MNX','MOO','MRUT','MSTD','NANOS','NDO','NDX','NDXP','NQX','NZD','OEF',
			'OEX','OIL','PZO','QQQ','RTY','RUT','RUTQ','RUTW','RVX','SFC','SKA','SPIKE','SPX','SPXPM','SPXQ','SPXW','SPY','SPY7','SVIX','SVXY',
			'UNG','UNG1','UNG2','UUP','UVIX','UVXY','UVXY1','UVXY2','VIIX','VIX','VIXM','VIXW','VIXY','VIXY1','VXEEM','VXX','VXX1','VXX2','VXXB',
			'VXZ','VXZ1','VXZB','XEO','XHB','XLB','XLC','XLE','XLF','XLF1','XLI','XLK','XLP','XLRE','XLU','XLV','XLY','XME','XND','XRT','XSP',
			'XSPAM','YUK','1SPY','2SPY','3SPY','4SPY','1QQQ','2QQQ','3QQQ','4QQQ','1EFA','2EFA','3EFA','4EFA','1GLD','2GLD','3GLD','4GLD','1IWM',
			'2IWM','3IWM','4IWM','1SPX','2SPX','3SPX','4SPX','1RUT','2RUT','3RUT','4RUT','1XSP','2XSP','3XSP','4XSP','1SPXW','2SPXW','3SPXW','4SPXW']

select a'AMJ','AUM','AUX','BACD','BPX','BRB','BSZ','BVZ','CDD','CITD','DBA','DBB','DBC','DBO','DIA','DJX','EEM','EFA','EUI','EUU','GBP','GLD',			'GSSD','IWM','IWN','IWO','IWV','JJC','JPMD','KBE','KRE','MDY','MNX','MOO','MRUT','MSTD','NANOS','NDO','NDX','NDXP','NQX','NZD','OEF',			'OEX','OIL','PZO','QQQ','RTY','RUT','RUTQ','RUTW','RVX','SFC','SKA','SPIKE','SPX','SPXPM','SPXQ','SPXW','SPY','SPY7','SVIX','SVXY',			'UNG','UNG1','UNG2','UUP','UVIX','UVXY','UVXY1','UVXY2','VIIX','VIX','VIXM','VIXW','VIXY','VIXY1','VXEEM','VXX','VXX1','VXX2','VXXB',			'VXZ','VXZ1','VXZB','XEO','XHB','XLB','XLC','XLE','XLF','XLF1','XLI','XLK','XLP','XLRE','XLU','XLV','XLY','XME','XND','XRT','XSP',			'XSPAM','YUK','1SPY','2SPY','3SPY','4SPY','1QQQ','2QQQ','3QQQ','4QQQ','1EFA','2EFA','3EFA','4EFA','1GLD','2GLD','3GLD','4GLD','1IWM',			'2IWM','3IWM','4IWM','1SPX','2SPX','3SPX','4SPX','1RUT','2RUT','3RUT','4RUT','1XSP','2XSP','3XSP','4XSP','1SPXW','2SPXW','3SPXW',`4SPXW`1



select * from jsonb_each('{"a": 1, "b": 2}'::jsonb);


select key, jsonb_array_elements(value)  from jsonb_each(:in_jsn::jsonb)
cross join lateral ;


select key, colmn.each -> 'cnt' as cnt, colmn.each -> 'opt_customer_firm' as opt_customer_firm
from jsonb_each(:in_jsn::jsonb)
cross join lateral jsonb_array_elements(value) colmn(each);


select *
from jsonb_to_recordset(:in_jsn::jsonb) as (cnt text, opt_customer_firm text);

create table bank.decs
(
    decs_id        int4 primary key generated by default as identity,
    account_name   text not null,
    publisher_name text not null
);
select * from bank.decs;
insert into bank.decs (account_name, publisher_name)
select md5(round(random()::numeric * 100, 0)::text), md5(round(random()::numeric * 30, 0)::text)
from generate_series(1, 1000000) as id;

alter table bank.decs add column account_id int4;
alter table bank.decs add column publisher_id int4;


create table bank.d_account
(
    account_id   int4 generated by default as identity,
    account_name text
);

create table bank.d_publisher
(
    publisher_id   int4 generated by default as identity,
    publisher_name text
);


do
$fx$
    begin
        insert into bank.d_account (account_name)
        select distinct account_name
        from bank.decs;

        insert into bank.d_publisher (publisher_name)
        select distinct publisher_name
        from bank.decs;

        update bank.decs de
        set account_id   = da.account_id,
            publisher_id = dp.publisher_id
        from bank.d_account da, bank.d_publisher dp
        where de.account_name = da.account_name
          and de.publisher_name = dp.publisher_name;
    end;
$fx$

select distinct account_id from bank.decs;


create table training.f_user_request
(
    request_id int4 primary key generated by default as identity ,
    user_id int4 not null,
    request_time timestamp
);

insert into training.f_user_request (user_id, request_time)
select round(random()::numeric * 100, 0), '2023-01-01'::timestamp + interval '1 minute' * round(random()::numeric * 445852, 0)
from generate_series(1, 1000000) as id;

select user_id, count(distinct request_time)
from training.f_user_request
group by user_id;

create index on training.f_user_request (user_id, request_time);

select max(interv) from (
select user_id,
       row_number() over w,
       request_time as tm,
       lag(request_time) over w as prev_tm,
       request_time - lag(request_time) over w as interv,
       extract(epoch from request_time - lag(request_time) over w) / 60 > 120
from training.f_user_request
window w as (partition by user_id order by request_time)) x;

drop table if exists training.t1;
drop table if exists training.t2;
drop table if exists training.t3;
drop table if exists training.t;

create table training.t1
(
    t1_id      int4,
    request_id int4
        constraint t1_request_pk primary key ,
    t1_txt     text
);
create table training.t2 (t2_id int4, t2_txt text);
create table training.t3 (t3_id int4, t3_txt text);
create table training.t (t_id int4, t_txt text);

insert into training.t1(t1_id, request_id, t1_txt)
select round(random()::numeric * 10000, 0),
       round(random()::numeric * 100000, 0),
       md5(round(random()::numeric * 30, 0)::text)
    from generate_series(1, 2000000)
on conflict (request_id) do nothing;

alter table training.t1 add constraint request_unk unique (request_id)

    insert into training.t2(t2_id, t2_txt)
select round(random()::numeric * 2, 0), md5(round(random()::numeric * 300, 0)::text)
    from generate_series(1, 20);

select * from training.t3;

with t1 as (select t1_id, t1_txt
            from training.t1)
   , t2 as (select t1_id, t1_txt
            from t1
            where t1_id < 5)
   , t3 as (
--     insert into training.t3 (t3_id, t3_txt)
--         select t1_id, t1_txt from t2)
    select from training.ins_something()
             )
-- insert
-- into training.t(t_id, t_txt)
select t1_id, t1_txt
from t1, t3
         left join training.t2 on t2.t2_id = t1.t1_id
left join t3 on true;

select fu.request_id, t1.request_id
from training.f_user_request fu
         join training.t1 on t1.request_id = fu.request_id
where fu.request_id < 20
  and fu.request_id > 10;

analyze training.t3

select t1.*
from training.t1
         left join lateral (select null from training.f_user_request fu where t1.request_id = fu.request_id limit 1) rt
                   on true
where t1.request_id <= 5000;


select version()

select * from training.ins_something()
create function training.ins_something()
returns int
    language plpgsql
as $$
    begin
        insert into training.t3 (t3_id, t3_txt)
        select * from (values (0, 'zero'), (1, 'one'), (2, 'two')) as t(digit, string);
        return 1;
    end;
    $$